///  main: _module.scss
///  ==========================================================================
///  Mixins
///  ==========================================================================



///  Size mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///  Set the height and width. If there is only 1 argument, set as square

@mixin size($width, $height: $width) {
  width: $width;
  height: $height;
}


///  Translate content into all of the languages listed in the $languages map
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin localize($key) {
  @each $language, $l in $languages {
    @at-root [lang="#{$language}"] & {
      content: localize('#{$language}.#{$key}');
    }
  }
}


///  Position mixins
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///  Use the position as the name of the mixin call (relative, absolute, fixed,
///  sticky, static). For paramenters, use positions followed by a space and
///  then values... i.e. @include relative(top 0 right 40px);

@mixin position($position, $args) {
	position: $position;
	@each $o in top right bottom left {
    $i: index($args, $o);

    @if $i and $i + 1 <= length($args) {
      #{$o}: nth($args, $i + 1);
    }
  }
}
@mixin absolute($args, $important: null) {
  @if ($important == "!important") {
    @include position(absolute!important, $args);
  }
  @else {
    @include position(absolute, $args);
  }
}
@mixin fixed($args, $important: null) {
  @if ($important == "!important") {
    @include position(fixed!important, $args);
  }
  @else {
    @include position(fixed, $args);
  }
}
@mixin relative($args, $important: null) {
  @if ($important == "!important") {
    @include position(relative!important, $args);
  }
  @else {
    @include position(relative, $args);
  }
}
@mixin sticky($args, $important: null) {
  @if ($important == "!important") {
    @include position(sticky!important, $args);
  }
  @else {
    @include position(sticky, $args);
  }
}
@mixin static($args, $important: null) {
  @if ($important == "!important") {
    @include position(static!important, $args);
  }
  @else {
    @include position(static, $args);
  }
}


$default-style-type: 'primary';

///  Scrollbar helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin scrollbar($type: $default-style-type, $direct: null) {
  // Check if 'alternate' or 'primary' is specified, if not throw an error
  // This can be removed if you want to allow more types to be used
  @if ($type != 'alternate') and ($type != 'primary') {
    @error "Unrecognized first argument of 'scrollbar' mixin.";
  }

  // Set this to true to attach the scrollbar directly to the element
  @if ($direct and $direct != '&') {
    @error "Unrecognized second argument of 'scrollbar' mixin. Please use '&' or leave this argument out.";
  }

  #{$direct}::-webkit-scrollbar {
    @include size(var(--scrollbar-#{$type}-size)!important);
    background-color: transparent!important;
    border-radius: var(--scrollbar-#{$type}-roundness)!important;
  }
  #{$direct}::-webkit-scrollbar-thumb {
    border: var(--scrollbar-#{$type}-border)!important;
    background-color: var(--scrollbar-#{$type}-thumb-color)!important;
    border-radius: var(--scrollbar-#{$type}-roundness)!important;
    box-shadow: var(--scrollbar-#{$type}-shadow);
  }
  #{$direct}::-webkit-scrollbar-track,
  #{$direct}::-webkit-scrollbar-track-piece {
    background-color: var(--scrollbar-#{$type}-track-color)!important;
    border-radius: var(--scrollbar-#{$type}-roundness)!important;
  }
}

///  Input helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin input($type: $default-style-type) {
  // Check if 'alternate' or 'primary' is specified, if not throw an error
  // This can be removed if you want to allow more types to be used
  @if ($type != 'alternate') and ($type != 'primary') {
    @error "Unrecognized argument of 'input' mixin.";
  }

  -webkit-appearance: none;
  appearance: none;
  border: var(--input-#{$type}-border)!important;
  border-radius: var(--input-#{$type}-roundness)!important;
  box-shadow: var(--input-#{$type}-shadow)!important;
  background: var(--input-#{$type}-color)!important;
  color: var(--input-#{$type}-text-color)!important;
  font-size: 12px!important;
  font-weight: 400!important;
  height: var(--input-#{$type}-size)!important;
  line-height: 1.5!important;
  outline: 0;
  transition: var(--disable-transitions, box-shadow .1s ease-in, border .1s ease-in);
  &:focus {
    border: var(--input-#{$type}-border-focus)!important;
    box-shadow: var(--input-#{$type}-shadow-focus)!important;
  }
  &::placeholder {
    color: var(--input-#{$type}-placeholder-color)!important;
    font-size: 12px!important;
    font-weight: 400;
  }
}


///  Button base styling
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin button-base {
  @include reset;
  border-radius: var(--button-roundness);
  cursor: pointer;
  display: inline-block;
  flex: none;
  font-size: 12px;
  font-weight: 400;
  height: 30px;
  line-height: 30px;
  min-height: 0;
  min-width: 0;
  transition: none;
  // Deciding to remove the transition, but leaving this here just in case
  // transition: var(--transition-none, background 0.12s ease-in, color 0.12s ease-in, box-shadow 0.12s ease-in);
}

///  Undoes button active style
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin button-undo-active {
  &:hover:active,
  &:active {
    border: none!important;
    box-shadow: none;
  }
}

///  Button helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin button($type: $default-style-type) {
  // Check if 'alternate' or 'primary' is specified, if not throw an error
  // This can be removed if you want to allow more types to be used
  @if ($type != 'primary') and
      ($type != 'hollow') and
      ($type != 'hollow-alternate') and
      ($type != 'blank') and
      ($type != 'success') and
      ($type != 'danger') and
      ($type != 'disabled') {
        @error "Unrecognized argument of 'button' mixin.";
  }

  background-color: var(--button-#{$type}-color)!important;
  border: var(--button-#{$type}-border)!important;
  box-shadow: var(--button-#{$type}-shadow)!important;
  color: var(--button-#{$type}-text-color)!important;
  &:hover {
    background-color: var(--button-#{$type}-hover-color)!important;
    border: var(--button-#{$type}-hover-border)!important;
    box-shadow: var(--button-#{$type}-hover-shadow)!important;
    color: var(--button-#{$type}-hover-text-color)!important;
  }
  &:hover:active,
  &:active {
    background-color: var(--button-#{$type}-active-color)!important;
    border: var(--button-#{$type}-active-border)!important;
    box-shadow: var(--button-#{$type}-active-shadow)!important;
    color: var(--button-#{$type}-active-text-color)!important;
  }
}



///  Alert helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin alert($type: $default-style-type) {
  // Check if 'notice' or 'success' or 'warn' or 'fail' is specified, if not throw an error
  // This can be removed if you want to allow more types to be used
  @if ($type != 'notice') and ($type != 'success') and ($type != 'warn') and ($type != 'fail') {
    @error "Unrecognized argument of 'alert' mixin.";
  }
  
  @include size(auto);
  background: var(--#{$type}-inner-color)!important;
  border: 2px solid var(--#{$type}-color)!important;
  border-radius: var(--button-roundness)!important;
  padding: 5px!important;
}



///  Header helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin header($type: null) {
  // Check if 'alternate' or 'primary' is specified, if not throw an error
  // This can be removed if you want to allow more types to be used
  @if ($type != 'h1') and ($type != 'h2') and ($type != 'h3') and ($type != 'h4') and ($type != 'h5') and ($type != 'h6') and ($type != 'h7') and ($type != 'h8') {
    @error "Unrecognized argument of 'header' mixin.";
  }

  color: var(--header-#{$type}-text-color)!important;
  font-weight: var(--header-#{$type}-weight)!important;
  font-size: var(--header-#{$type}-size)!important;
  line-height: var(--header-#{$type}-line-height)!important;
}


// This is tomfoolery to place a pseudoelemtn over the scroller div's scrollbar
// giving it a deception of fading in/out. You may need to add z-index: auto to the
// scroller div to get it to work effectively.
@mixin fakeScrollbarFade($element: null) {
  &::after {
    @include absolute(top 0 right 0);
    @include size(var(--scrollbar-primary-size)!important, 100%!important);
    content: '';
    background: var(--#{$element}-color);
    opacity: 1!important;
    pointer-events: none;
    transition: opacity 0.2s linear;
    transition-delay: 1.3s;
    visibility: visible!important;
    will-change: opacity;
  }
  &:hover {
    &::after {
      animation: scrollbarFade 1.5s linear;
    }
  }
  &.scrolling-CehiO2 {
    &::after {
      opacity: 0!important;
      transition-delay: 0s;
    }
  }
}

///  Flex centering mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}


///  Opposite direction mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///  Returns the opposite direction of each direction in a list
///  @param {List} $directions - List of initial directions
///  @return {List} - List of opposite directions

@function opposite-direction($directions) {
  $opposite-directions: ();
  $direction-map: (
    'top':    'bottom',
    'right':  'left',
    'bottom': 'top',
    'left':   'right',
    'center': 'center',
    'ltr':    'rtl',
    'rtl':    'ltr'
  );

  @each $direction in $directions {
    $direction: to-lower-case($direction);

    @if map-has-key($direction-map, $direction) {
      $opposite-directions: append($opposite-directions, unquote(map-get($direction-map, $direction)));
    } @else {
      @warn "No opposite direction can be found for `#{$direction}`. Direction omitted.";
    }
  }

  @return $opposite-directions;
}


///  Triangle helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///  @param {Direction} $direction - Triangle direction, either `top`, `right`, `bottom` or `left`
///  @param {Color} $color - Triangle color
///  @param {Length} $size - Triangle size

@mixin triangle($direction, $color: null, $size: null) {
  @if not index(top right bottom left, $direction) {
    @error "Direction must be either `top`, `right`, `bottom` or `left`.";
  }

  @include size(0);
  content: '';
  border-#{opposite-direction($direction)}: $size solid $color!important;
  $perpendicular-borders: $size solid transparent!important;

  @if $direction == top or $direction == bottom {
    border-left: $perpendicular-borders;
    border-right: $perpendicular-borders;
  } @else if $direction == right or $direction == left {
    border-bottom: $perpendicular-borders;
    border-top: $perpendicular-borders;
  }
}


///  Masking mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin mask($image, $bg-color: null, $size: null, $extras: no-repeat center, $important: false) {
	@if ($important) {
    -webkit-mask: $image $extras!important;
    mask: $image $extras!important;
    @if ($bg-color) {
      background-color: $bg-color!important;
    }
    @if ($size) {
      -webkit-mask-size: $size!important;
      mask-size: $size!important;
    }
  } @else {
    -webkit-mask: $image $extras;
    mask: $image $extras;
    @if ($bg-color) {
      background-color: $bg-color;
    }
    @if ($size) {
      -webkit-mask-size: $size;
      mask-size: $size;
    }
  }
}


///  Hardware acceleration mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin hardware($backface: true, $perspective: 1000) {
  @if $backface {
    backface-visibility: hidden;
  }
  -webkit-perspective: $perspective;
  perspective: $perspective;
}


///  Text helper mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin text($color: null, $size: null, $weight: null, $lh: null, $transform: null) {
  color: $color;
  font-size: $size;
  font-weight: $weight;
  line-height: $lh;
  text-transform: $transform;
}


///  Margin/padding reset mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin reset {
  margin: 0;
  padding: 0;
}


///  Text truncate mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@mixin ellipsis($max-width: null, $display: null) {
  max-width: $max-width;
  display: $display;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}


///  Breakpoint mixin
///  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///  Wraps a media query around the content you put inside the mixin. This mixin accepts a number of values:
///  - If a string is passed, the mixin will look for it in the $Breakpoints map, and use a media query there.
///  - If a pixel value is passed, it will be converted to an em value using $rem-base.
///  - If a rem value is passed, the unit will be changed to em.
///  - If an em value is passed, the value will be used as-is.
///  - From Zurb Foundation
///
///  @param {mixed} $val - Breakpoint name or px/em/rem value to process.
///  @output If the breakpoint is "0px and larger", outputs the content. Otherwise, outputs the content wrapped in a media query.

@mixin breakpoint($val: small) {
  // Size or keyword
  $bp: nth($val, 1);
  // Value for max-width media queries
  $bpMax: 0;
  // Direction of media query (up, down, or only)
  $dir: if(length($val) > 1, nth($val, 2), down);
  // Eventual output
  $str: 'only screen';
  // Is it a named media query?
  $named: false;

  // Orientation media queries have a unique syntax
  @if $bp == 'landscape' or $bp == 'portrait' {
    $str: $str + ' and (orientation: #{$bp})';
  }
  @else {
    // Try to pull a named breakpoint out of the $Breakpoints map
    @if type-of($bp) == 'string' {
      @if map-has-key($breakpoints, $bp) {
        @if $dir == 'only' {
          $next-bp: map-next($breakpoints, $bp);
          @if $next-bp == null {
            $bpMax: null;
          }
          @else {
            $bpMax: $next-bp - (1/16);
          }
        }
        $bp: map-get($breakpoints, $bp);
        $named: true;
      }
      @else {
        $bp: 0;
      }
    }

    // Pixel and unitless values are converted to rems
    @if unit($bp) == 'px' or unit($bp) == '' {
      $bp: rem-calc($bp);
    }
    // Finally, the rem value is turned into an em value
    $bp: strip-unit($bp) * 1em;

    // Skip media query creation if the input is "0 up" or "0 down"
    @if $bp > 0 or $dir == 'only' {
      // And lo, a media query was born
      @if $dir == 'only' {
        @if $named == true {
          $str: $str + ' and (min-width: #{$bp})';
          @if $bpMax != null {
            $str: $str + ' and (max-width: #{$bpMax})';
          }
        }
        @else {
          @debug 'ERROR: Only named media queries can have an "only" range.';
        }
      }
      @else if $dir == 'down' {
        $max: $bp - (1/16);
        $str: $str + ' and (max-width: #{$max})';
      }
      @else {
        $str: $str + ' and (min-width: #{$bp})';
      }
    }
  }

  // Output
  @if $bp == 0em and $dir != 'only' {
    @content;
  }
  @else {
    @media #{$str} {
      @content;
    }
  }
}